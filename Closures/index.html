<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>JS Functions</title>
    <script type="text/javascript" src="js/closures.js"></script>
</head>

<body>
    <h3>Todas as funções estão escrevendo no Console</h3>
    <br />
    <div>
        <p>
            Closures
        </p>
        <label>
            Closures possuem duas caracteristicas importantes:
            <br />
            A primeira é tirar vantagem do Lexical Scope.
            Que no caso, é a habilidade de uma função javascript enxergar as variaveis vindas de um escopo pai.
            <br />
            A segunda é a memorização do escopo de onde a variavel foi criada
        </label>
    </div>
    <div>
        <p>
            A primeira caracteristica, de escopo lexico, pode ser notada neste exemplo.
        </p>
        <p>
            Aqui, escrevemos o seguinte codigo:
        </p>
        <p>
            <code>
                function imprimeValor(){
                <br>
                let nome = 'Jose';
                <br>
                return function(){
                <br>
                return nome;
                <br>
                }
                <br>
                }
                <br>
                var fn = imprimeValor();
                <br>
                console.log(fn());
            </code>
        </p>
        <p>
            Neste exemplo, a variavel nome, declarada na função imprimeValor, pode ser acessada normalmente
            na função anonima.
            Isso mostra o funcionamento do escopo lexico.
        </p>
        <p>
            A segunda caracteristica, memorização, pode ser notada no mesmo exemplo.
        </p>
        <p>
            Quando a função imprimeValor é executada, a variavel nome, declarada no escopo dela, permanece "em memoria",
            permitindo que novas execuções tragam o valor que a mesma recebeu na execução original.
            Seu escopo é memorizado, e pode ser resgatado em chamadas futuras.
        </p>
        <p>
            Outra caracteristica importante de closure, é o encapsulamento de valores.
            Conforme demonstrado pelo codigo, quando declaramos uma função, dentro de outra, mas não expomos por
            return, ela se torna privada, existindo apensar dentro do escopo da primeira função.
            <br><br>
            <code>
                function minhaBiblioteca(){
                    <br>
                    function auxiliar(valor){
                    <br>
                    return 10 + valor;
                    <br>
                    }
                    <br>
                    return{
                    <br>
                    add5(){
                    <br>
                    return auxiliar(5);
                    <br>
                    },
                    <br>
                    add7(){
                    <br>
                    return auxiliar(7);
                    <br>
                    }
                    }
                    }
            </code>
            <br><br>
            Neste exemplo, a função auxiliar só existe dentro do escopo da função minhaBiblioteca
        </p>
        <p>
            Outra caracteristica do closure, é ajudar a evitar funções anonimas.
        </p>
        <p>
            Neste exemplo, a função inicializa, atraves de um setTimeout invoca a função imprimeNome.
            Porem, o setTimeout espera uma função como seu primeiro parametro, deste modo, dentro da função
            imprimeNome, usamos como retorno uma função anonima, e atraves do closure, a variavel nome, que foi
            criada no escopo da função imprimeNome é memorizada e utilizada na função anonima.
        </p>
        <p>
            <code>
                function imprimeNome(nome){<br>
                return function(){<br>
                console.log(nome, 'Abadaba');<br>
                }
                }
                <br><br>
                function inicializa(){<br>
                let nome = 'Jose';<br>
                setTimeout(imprimeNome(nome), 1000)<br>
                }
            </code>
        </p>
        <p>
            Este exemplo poderia ser resolvi atraves de outra maneira:
            Porem, desta forma, iriamos utilizar uma função anonima, em um local indesejado.
            Por isso, utilizamos os conceitos de closure para produzir a nova função.
            <br><br>
            <code>
                function inicializa(){<br>
                let nome = 'Jose';<br>
                setTimeout(function(){<br>
                console.log(nome);<br>
                }, 1000)<br>
                }
            </code>
        </p>
    </div>
</body>

</html>