<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>JS Functions</title>
    <script type="text/javascript" src="js/filter.js"></script>
</head>

<body>
    <h3>Filter</h3>
    <div>
        <p>
            Filter, como o proprio nome diz, tem o objtivo de filtrar um array.
            <br>
            Assim como o map, o Filter itera sob um array, e espera uma função como callback, porem, ele tem como um
            retorno um parametro booleano.
            <br>
            Isso pode parecer estranho, porem atraves dos exemplos, vamos notar que é mais simples do que parece.
            <br>
            Neste exemplo, vamos iterar sobre um array de numeros, e retornoar apenas os numeros multiplos de 2.
            <br>
        </p>
        <p>
            Primeiro, uma ireação tradicional com um loop <code>for</code>.
        </p>
        <p>
            <code>
                const numeros = [2,3,6,5,10];
                <br>
                let novoArrayNumeros = [];
                <br>
                for(let i = 0; i < numeros.length; i++){
                    <br>
                    console.log(`Numeros: ${numeros[i]*2}`);
                    <br>
                    if(numeros[i] % 2 === 0){
                        <br>
                        novoArrayNumeros.push(numeros[i]);
                        <br>
                    }
                    <br>
                }  
            </code>
            <br><br>
            Acima temos a iteração comum, com um laço <code>for</code>.
            <br>
            Podemos notar que, para atingir nosso objetivo, novamente foi necessario criar a variavel novoArrayNumeros
            fora do
            escopo de execução do <code>for</code>, para que assim fosse possivel, iterar, identificar e criar uma nova
            saída.
        </p>
        <p>
            Agora, um exemplo com o <code>filter</code>
            <br><br>
            <code>
                const novoArrayNumerosFilter = numeros.filter(function(numero){
                    <br>
                    if(numero % 2 === 0){
                        <br>
                        return true;
                        <br>
                    }else{
                        <br>
                        return true;
                        <br>
                    }
                    <br>
                });
            </code>
            <br><br>
            Acima, tem a mesma iteração, porem utilizando o <code>map</code>.
            Como a função <code>filter</code> pede uma função de <code>callback</code> como parametro, e sempre ira
            retornar um booleano, nós realizamos a varificação do valor, na função de <code>callback</code>, e os
            valores que atenderem a esta verificação, serão retornados como um novo array.
            <br>
            Com isso, podemos notar o que foi mencionado sobre o retorno booleano do filter.
            <br>
            Deste forma, ambos arrays coexistem, e nenhuma variavel foi criada fora do escopo para atender a esse
            cenario.
            <br>
            Outro detalhe, é o fato de que utilizando o <code>filter</code> para atender a este cenario, nosso
            desenvolvimento ficou mais legivel e limpo.
            <br><br>
            Porem, existem ainda outras formas de deixar esta implementação ainda mais compacta, se utilizarmos outros
            recursos qud o Javascript fornece.
            <br><br>
            <code>
                const numeroFiltrados = numeros.filter(numero => numero % 2 === 0);
            </code>
            <br><br>
            Acima, temos a mesma implementação, utilizando alem do <code>filter</code>, uma arrow function.
            <br>
            Desse modo, conseguimos realizar a mesma iteração, em apenas uma linha.

        </p>
    </div>
    <div>
        <label>
            <a href="../index.html">Voltar</a>
        </label>
    </div>
</body>

</html>